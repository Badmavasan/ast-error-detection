# Error Tags

# not used
FOR_LOOP_INCORRECT_NUMBER_OF_ITERATIONS = "FOR_LOOP_INCORRECT_NUMBER_OF_ITERATIONS"

FOR_LOOP_MISSING = "FOR_LOOP_MISSING"
FOR_LOOP_BODY_MISMATCH = "FOR_LOOP_BODY_MISMATCH"
MISSING_STATEMENT = "MISSING_STATEMENT"
ERROR_VALUE_PARAMETER = "ERROR_VALUE_PARAMETER"
VAR_CONST_MISMATCH = "CONST_VALUE_MISMATCH"

# VAR
VA_DECLARATION_INITIALIZATION_ERROR = "VA_DECLARATION_INITIALIZATION_ERROR"

# CS
CS_BODY_ERROR = "CS_BODY_ERROR"
CS_BODY_MISPLACED = "CS_BODY_MISPLACED"
CS_MISSING = "CS_MISSING"

# FUNCTION
F_DEFINITION_MISSING = "F_DEFINITION_MISSING"
F_DEFINITION_ERROR_ARG = "F_DEFINITION_ERROR_ARG"
F_DEFINITION_ERROR_RETURN = "F_DEFINITION_ERROR_RETURN"

# LOOP
LO_FOR_NUMBER_ITERATION_ERROR = "LO_FOR_NUMBER_ITERATION_ERROR"
LO_FOR_NUMBER_ITERATION_ERROR_UNDER2 = "LO_FOR_NUMBER_ITERATION_ERROR_UNDER2"
LO_WHILE_NUMBER_ITERATION_ERROR = "LO_WHILE_NUMBER_ITERATION_ERROR"
LO_WHILE_NUMBER_ITERATION_ERROR_UNDER2 = "LO_WHILE_NUMBER_ITERATION_ERROR_UNDER2"
LO_BODY_MISSING_NOT_PRESENT_ANYWHERE = "LO_BODY_MISSING_NOT_PRESENT_ANYWHERE"
LO_BODY_MISPLACED = "LO_BODY_MISPLACED"
LO_BODY_ERROR = "LO_BODY_ERROR"
LO_FOR_MISSING = "LO_FOR_MISSING"
LO_WHILE_MISSING = "LO_WHILE_MISSING"
LO_CONDITION_ERROR = "LO_CONDITION_ERROR"

# EXPRESSION
EXP_ERROR_CONDITIONAL_BRANCH = "EXP_ERROR_CONDITIONAL_BRANCH"

# ALGORITHM AND PROGRAM
PA_PROBLEM_DECOMPOSITION_ALGORITHMIC_STRATEGIE_ERROR = "PA_PROBLEM_DECOMPOSITION_ALGORITHMIC_STRATEGIE_ERROR"



# Annotation Tags

ANNOTATION_TAG_CONST_VALUE_MISMATCH = "CONST_VALUE_MISMATCH"
ANNOTATION_TAG_MISSING_FOR_LOOP = "MISSING_FOR_LOOP"
ANNOTATION_TAG_MISSING_WHILE_LOOP = "MISSING_WHILE_LOOP"
ANNOTATION_TAG_MISSING_CS = "MISSING_IF_STATEMENT"
ANNOTATION_TAG_MISSING_FUNCTION_DEFINITION = "MISSING_FUNCTION_DEFINITION"
ANNOTATION_TAG_MISSING = "MISSING"
ANNOTATION_TAG_INCORRECT_POSITION_LOOP = ["INCORRECT_STATEMENT_POSITION_FOR", "INCORRECT_STATEMENT_POSITION_WHILE"]
ANNOTATION_TAG_INCORRECT_POSITION_CS = "INCORRECT_STATEMENT_POSITION_IF"
ANNOTATION_TAG_MISSING_ARGUMENT = "MISSING_ARGUMENT"
ANNOTATION_TAG_UNNECESSARY_ARGUMENT = "UNNECESSARY_ARGUMENT"
ANNOTATION_TAG_MISSING_RETURN = "MISSING_RETURN"
ANNOTATION_TAG_UNNECESSARY_RETURN = "UNNECESSARY_RETURN_IN_FUNCTION"
ANNOTATION_TAG_MISSING_VARIABLE = "MISSING_VARIABLE"
ANNOTATION_TAG_INCORRECT_OPERATION_IN_EXP = "INCORRECT_OPERATION_IN_CONDITION"
ANNOTATION_TAG_UNNECESSARY_CALL_STATEMENT = "UNNECESSARY_CALL_STATEMENT"

# Annotation Contexts

ANNOTATION_CONTEXT_FOR_LOOP_BODY = "Module > For > Body"
ANNOTATION_CONTEXT_WHILE_LOOP_BODY = "Module > While > Body"
ANNOTATION_CONTEXT_WHILE_LOOP_CONDITION = "While > Condition"
ANNOTATION_CONTEXT_CS_BODY = "Module > If > Body"
ANNOTATION_CONTEXT_CS_CONDITION = "If > Condition"
ANNOTATION_CONTEXT_VAR = "Module > Assign"
ANNOTATION_CONTEXT_RETURN_1 = "Module > Function"
ANNOTATION_CONTEXT_RETURN_2 = "Return > Tuple"

# This regex checks if the context ends with a pattern like:
# "Call: <any_text> > Const: <any_text>"
ANNOTATION_CONTEXT_FUNCTION_PARAMETER = r"Call:\s*.+\s*>\s*Const:\s*.+\s*$"




